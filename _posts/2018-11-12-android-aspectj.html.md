---
layout: post
title: Android Aspectj 로 로그 정성껏 출력해보기.. 머래...
date: '2018-11-12T19:18:00.000-08:00'
author: schoolhompy
tags: 
modified_time: '2019-11-03T17:47:55.473-08:00'
blogger_id: tag:blogger.com,1999:blog-4954243635432022205.post-8918750517850304377
blogger_orig_url: https://yunhos.blogspot.com/2018/11/android-aspectj.html
---

import android.content.ContentValues;<br />import android.content.Context;<br />import android.graphics.Bitmap;<br />import android.os.Debug;<br />import android.os.Environment;<br />import android.support.annotation.NonNull;<br />import android.util.Log;<br />import android.view.View;<br /><br /><br />import com.afwsamples.testdpc.Application;<br /><br />import org.aspectj.lang.JoinPoint;<br />import org.aspectj.lang.ProceedingJoinPoint;<br />import org.aspectj.lang.annotation.Around;<br />import org.aspectj.lang.annotation.Aspect;<br />import org.aspectj.lang.annotation.Before;<br />import org.aspectj.lang.annotation.Pointcut;<br />import org.aspectj.lang.reflect.MethodSignature;<br /><br />import java.io.File;<br />import java.io.FileNotFoundException;<br />import java.io.FileOutputStream;<br />import java.io.IOException;<br />import java.io.OutputStream;<br />import java.util.ArrayList;<br />import java.util.HashMap;<br />import java.util.List;<br />import java.util.Random;<br />import java.util.concurrent.TimeUnit;<br /><br />@Aspect<br />public final class AspectDebugLog {<br />&nbsp; &nbsp; //Line형태의 시퀀스 로그<br />&nbsp; &nbsp; private static final String ASPECT_LOG_SEQUENCE_TYPE = "ALOGSEQ";<br /><br />&nbsp; &nbsp; //PlantUML에 이용하기 위한 로그<br />&nbsp; &nbsp; private static final String ASPECT_LOG_PLANTUML_TYPE = "ALOGUML";<br /><br />&nbsp; &nbsp; //버퍼를 모아서 디비에 출력하기용.<br />&nbsp; &nbsp; private static int logBufferCount = 1;<br />&nbsp; &nbsp; //Limit 만큼 카운트가 되면 디비에 저장.<br />&nbsp; &nbsp; private static int logBufferStoreCountLimit = 3000;<br /><br />&nbsp; &nbsp; //버퍼를 모아서 디비에 출력하기용. 프로비저닝 등의 작업에서는 로그출력이 불가능하니까 사용<br />&nbsp; &nbsp; private static String logBufferMessages = "";<br /><br />&nbsp; &nbsp; private static HashMap&lt;Integer, List&lt;String&gt;&gt; depthTexts = new HashMap&lt;&gt;();<br />&nbsp; &nbsp; private static HashMap&lt;Integer, Integer&gt; depthCounts = new HashMap&lt;&gt;();<br />&nbsp; &nbsp; private static HashMap&lt;Integer, Integer&gt; processColor = new HashMap&lt;&gt;();<br /><br />&nbsp; &nbsp; private static String verticalLine = "│";<br />&nbsp; &nbsp; private String lastClassMethod = "Start";<br /><br /><br />&nbsp; &nbsp; private static final String START = "Start";<br />&nbsp; &nbsp; private static final String ACTIVATE = "activate ";<br />&nbsp; &nbsp; private static final String DEACTIVATE = "deactivate ";<br /><br />&nbsp; &nbsp; private int logType1 = 1;<br />&nbsp; &nbsp; private String argAll;<br /><br />&nbsp; &nbsp; private static final String POINTCUT_BEFORE_METHOD =<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "(" +<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "execution(* com.afwsamples.testdpc..*.*(..)) " +<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ")" +<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; " &amp;&amp; !(" +<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "execution(* com.afwsamples.testdpc.Application*..*(..))" +<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ")";<br /><br />&nbsp; &nbsp; private static final String POINTCUT_AROUND_METHOD = POINTCUT_BEFORE_METHOD;<br /><br />&nbsp; &nbsp; @Pointcut(POINTCUT_BEFORE_METHOD)<br />&nbsp; &nbsp; public void pointcutDebugTraceBefore() {}<br /><br />&nbsp; &nbsp; @Pointcut(POINTCUT_AROUND_METHOD)<br />&nbsp; &nbsp; public void pointcutDebugTraceAround() {}<br /><br />&nbsp; &nbsp; @Before("pointcutDebugTraceBefore()")<br />&nbsp; &nbsp; public void weaveDebugTraceBefore(JoinPoint joinPoint) throws Throwable {<br />&nbsp; &nbsp; &nbsp; &nbsp; MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();<br />&nbsp; &nbsp; &nbsp; &nbsp; String currentClassName = utils.getOnlyClassName(methodSignature.getDeclaringType().getSimpleName());<br />&nbsp; &nbsp; &nbsp; &nbsp; String currentMethodName = utils.getOnlyClassName(methodSignature.getName());<br />&nbsp; &nbsp; &nbsp; &nbsp; //not use<br />&nbsp; &nbsp; &nbsp; &nbsp; argAll = utils.getArgs(joinPoint, methodSignature);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; int tid = android.os.Process.myTid();<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; List&lt;String&gt; dummyDepthText = utils.getdepthTexts(tid);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; lastClassMethod = utils.getLastClassMethod(lastClassMethod, dummyDepthText, logType1);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; if (utils.getdepthCounts(tid) &lt; 1) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lastClassMethod = "Start";<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; LogPrinter.logBefore(currentClassName, currentMethodName, lastClassMethod, tid);<br />&nbsp; &nbsp; &nbsp; &nbsp; LogPrinter.logBeforeArg(lastClassMethod, tid, argAll);<br /><br /><br />&nbsp; &nbsp; &nbsp; &nbsp; printTo(type2PrintTid(tid) + ASPECT_LOG_SEQUENCE_TYPE, utils.repeat(verticalLine, utils.getdepthCounts(tid) + 1) + "▼" + "(" + joinPoint.getSignature().getDeclaringType() + ") ");<br />&nbsp; &nbsp; &nbsp; &nbsp; printTo(type2PrintTid(tid) + ASPECT_LOG_SEQUENCE_TYPE, utils.repeat(verticalLine, utils.getdepthCounts(tid) + 1) + "┏ " + currentMethodName);<br /><br /><br />&nbsp; &nbsp; &nbsp; &nbsp; dummyDepthText.add(currentClassName);<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; @NonNull<br />&nbsp; &nbsp; public static String type2PrintTid(int tid) {<br />&nbsp; &nbsp; &nbsp; &nbsp; return tid + ": p-";<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; @NonNull<br />&nbsp; &nbsp; public static String type2PrintTidForUml(int tid) {<br />&nbsp; &nbsp; &nbsp; &nbsp; return "";<br />&nbsp; &nbsp; }<br /><br /><br />&nbsp; &nbsp; @Around("pointcutDebugTraceAround()")<br />&nbsp; &nbsp; public Object weaveDebugTraceAround(ProceedingJoinPoint joinPoint) throws Throwable {<br />&nbsp; &nbsp; &nbsp; &nbsp; MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();<br />&nbsp; &nbsp; &nbsp; &nbsp; String currentClassName = utils.getOnlyClassName(methodSignature.getDeclaringType().getSimpleName());<br />&nbsp; &nbsp; &nbsp; &nbsp; String currentMethodName = utils.getOnlyClassName(methodSignature.getName());<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; int tid = android.os.Process.myTid();<br />&nbsp; &nbsp; &nbsp; &nbsp; List&lt;String&gt; dummyDepthText = utils.getdepthTexts(tid);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; depthCounts.put(tid, utils.getdepthCounts(tid) + 1);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; LogPrinter.logAroundBefore(currentClassName, tid);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; if (argAll.length() &gt; 0) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printTo(type2PrintTid(tid) + ASPECT_LOG_SEQUENCE_TYPE,&nbsp; utils.repeat(verticalLine, utils.getdepthCounts(tid) + 1) + argAll);<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; StopWatch stopWatch = new StopWatch();<br />&nbsp; &nbsp; &nbsp; &nbsp; stopWatch.start();<br />&nbsp; &nbsp; &nbsp; &nbsp; Object result = joinPoint.proceed();<br />&nbsp; &nbsp; &nbsp; &nbsp; stopWatch.stop();<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; LogPrinter.logAroundAfter(currentClassName, currentMethodName, dummyDepthText, stopWatch.getTotalTimeMillis(), tid, result);<br /><br /><br />&nbsp; &nbsp; &nbsp; &nbsp; printTo(type2PrintTid(tid) + ASPECT_LOG_SEQUENCE_TYPE,&nbsp; utils.repeat(verticalLine, utils.getdepthCounts(tid) + 1) + "result&nbsp; " + result );<br />&nbsp; &nbsp; &nbsp; &nbsp; printTo(type2PrintTid(tid) + ASPECT_LOG_SEQUENCE_TYPE,&nbsp; utils.repeat(verticalLine, (utils.getdepthCounts(tid))) +<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "┗ " + currentMethodName +<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; " : " + stopWatch.getTotalTimeMillis() + "ms");<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; //after process<br />&nbsp; &nbsp; &nbsp; &nbsp; depthCounts.put(tid, utils.getdepthCounts(tid) - 1);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; if(dummyDepthText.size() &gt;0) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dummyDepthText.remove(dummyDepthText.size()-1);<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; depthTexts.put(tid, dummyDepthText);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; return result;<br />&nbsp; &nbsp; }<br /><br />/*&nbsp; &nbsp; @Around("(execution(* android.app.Activity.onResume(..)) || execution(* android.app.Activity.onCreate(..)) || execution(* show(..)) )")<br />&nbsp; &nbsp; public Object postonResume(ProceedingJoinPoint joinPoint) throws Throwable {<br />&nbsp; &nbsp; &nbsp; final Activity activity = (Activity) joinPoint.getTarget();<br />&nbsp; &nbsp; &nbsp; &nbsp; final View rootView = activity.getWindow().getDecorView().getRootView();<br /><br /><br />&nbsp; &nbsp; &nbsp; &nbsp; final Handler handler = new Handler();<br />&nbsp; &nbsp; &nbsp; &nbsp; handler.postDelayed(new Runnable() {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @Override<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; public void run() {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; storeScreenshot(takescreenshotOfRootView(rootView), Calendar.getInstance().getTimeInMillis() + "-" + activity.getLocalClassName()&nbsp; );<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; }, 500);<br />&nbsp; &nbsp; &nbsp; &nbsp; Object result = joinPoint.proceed();<br />&nbsp; &nbsp; &nbsp; &nbsp; return result;<br />&nbsp; &nbsp; }*/<br /><br /><br />&nbsp; &nbsp; public static Bitmap takescreenshot(View v) {<br />&nbsp; &nbsp; &nbsp; &nbsp; v.setDrawingCacheEnabled(true);<br />&nbsp; &nbsp; &nbsp; &nbsp; v.buildDrawingCache(true);<br />&nbsp; &nbsp; &nbsp; &nbsp; Bitmap b = Bitmap.createBitmap(v.getDrawingCache(true));<br />&nbsp; &nbsp; &nbsp; &nbsp; v.setDrawingCacheEnabled(false);<br />&nbsp; &nbsp; &nbsp; &nbsp; return b;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; public static Bitmap takescreenshotOfRootView(View v) {<br />&nbsp; &nbsp; &nbsp; &nbsp; return takescreenshot(v.getRootView());<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; public void storeScreenshot(Bitmap bitmap, String filename) {<br />&nbsp; &nbsp; &nbsp; &nbsp; String path = Environment.getExternalStorageDirectory().toString() + "/" + filename + ".jpg";<br />&nbsp; &nbsp; &nbsp; &nbsp; Log.e("path", path);<br />&nbsp; &nbsp; &nbsp; &nbsp; OutputStream out = null;<br />&nbsp; &nbsp; &nbsp; &nbsp; File imageFile = new File(path);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; try {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; out = new FileOutputStream(imageFile);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // choose JPEG format<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitmap.compress(Bitmap.CompressFormat.JPEG, 70, out);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; out.flush();<br />&nbsp; &nbsp; &nbsp; &nbsp; } catch (FileNotFoundException e) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Log.e("FileNotFoundException", e.getMessage());<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // manage exception ...<br />&nbsp; &nbsp; &nbsp; &nbsp; } catch (IOException e) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Log.e("IOException", e.getMessage());<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // manage exception ...<br />&nbsp; &nbsp; &nbsp; &nbsp; } finally {<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (out != null) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; out.close();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } catch (Exception exc) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; /**<br />&nbsp; &nbsp; &nbsp;* Class representing a StopWatch for measuring time.<br />&nbsp; &nbsp; &nbsp;*/<br />&nbsp; &nbsp; public class StopWatch {<br />&nbsp; &nbsp; &nbsp; &nbsp; private long startTime;<br />&nbsp; &nbsp; &nbsp; &nbsp; private long endTime;<br />&nbsp; &nbsp; &nbsp; &nbsp; private long elapsedTime;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; public StopWatch() {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //empty<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; private void reset() {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startTime = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; endTime = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elapsedTime = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; public void start() {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reset();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startTime = System.nanoTime();<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; public void stop() {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (startTime != 0) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; endTime = System.nanoTime();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elapsedTime = endTime - startTime;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reset();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; public long getTotalTimeMillis() {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return (elapsedTime != 0) ? TimeUnit.NANOSECONDS.toMillis(endTime - startTime) : 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; public static class LogPrinter {<br /><br /><br />&nbsp; &nbsp; &nbsp; &nbsp; private static void logBefore(String className, String methodName, String lastClassMethod, int&nbsp; tid ) {<br /><br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //hidden for UML<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printTo(ASPECT_LOG_PLANTUML_TYPE,&nbsp; &nbsp;type2PrintTidForUml(tid) + lastClassMethod + umlWithColorBlock(tid) + "-&gt;" + type2PrintTidForUml(tid) + className + " : " + methodName&nbsp; + "#" + tid );<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; public static void logBeforeArg(String className,&nbsp; int&nbsp; tid, String args) {<br />//&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; note right of Alice<br />//&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Alice の&lt;u:blue&gt;右&lt;/u&gt;側に<br />//&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;back:cadetblue&gt;表示&lt;/back&gt;するノート<br />//&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end note<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(args.isEmpty()) return;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printTo(ASPECT_LOG_PLANTUML_TYPE,&nbsp; &nbsp;"note right of " +&nbsp; type2PrintTidForUml(tid) + className&nbsp; &nbsp;+ "\n " + args + "\n end note"&nbsp; );<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; public static void logAfterResult(String className,&nbsp; int&nbsp; tid, Object result) {<br />//&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; note right of Alice<br />//&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Alice の&lt;u:blue&gt;右&lt;/u&gt;側に<br />//&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;back:cadetblue&gt;表示&lt;/back&gt;するノート<br />//&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end note<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(result == null) return;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printTo(ASPECT_LOG_PLANTUML_TYPE,&nbsp; &nbsp;"note right of " +&nbsp; type2PrintTidForUml(tid) + className&nbsp; &nbsp;+ "\n result :" + result + "\n end note"&nbsp; );<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /><br /><br />&nbsp; &nbsp; &nbsp; &nbsp; private static int getProcessColor(int tid) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(!processColor.containsKey(tid)) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Random r = new Random();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; processColor.put(tid, r.nextInt(0xffffff + 1));<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return processColor.get(tid);<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; private static String umlWithColor(int tid) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return String.format("#%06x", getProcessColor(tid));<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; private static String umlWithColorBlock(int tid) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return "[" + umlWithColor(tid) + "]";<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; private static void logAroundBefore(String className, int tid) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //hidden for UML<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printTo(ASPECT_LOG_PLANTUML_TYPE, ACTIVATE + type2PrintTidForUml(tid) + className + " " + umlWithColor(tid));<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; private static void logAroundAfter(String className, String methodName, List&lt;String&gt; depthText, long estimate, int&nbsp; tid, Object result ) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; String returnClassName = START;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(depthText.size() &gt; 1) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returnClassName = depthText.get(depthText.size()-2);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //hidden for UML<br />//new but not goof&nbsp; &nbsp;relation 420,423&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printTo(ASPECT_LOG_PLANTUML_TYPE, "return " +type2PrintTidForUml(tid) + methodName + "&nbsp; (" + estimate + "ms)"); //### weaveDebugTraceBefore:<br /><br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; long nativeMax = Debug.getNativeHeapSize() / 1024;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; long nativeAllocated = Debug.getNativeHeapAllocatedSize() / 1024;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; long nativeFree = Debug.getNativeHeapFreeSize() / 1024;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printTo(ASPECT_LOG_PLANTUML_TYPE, type2PrintTidForUml(tid) + className + umlWithColorBlock(tid)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + "--&gt;" + type2PrintTidForUml(tid) + returnClassName + " : " + methodName + "#" + tid&nbsp; + "&nbsp; (" + estimate + "ms," + nativeMax + "MB," + nativeAllocated + "MB," + nativeFree + "MB)"); //### weaveDebugTraceBefore:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LogPrinter.logAfterResult(className,&nbsp; tid,&nbsp; result);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //hidden for UML<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printTo(ASPECT_LOG_PLANTUML_TYPE, DEACTIVATE + type2PrintTidForUml(tid) + className + " " +&nbsp; umlWithColor(tid) );<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; public static class utils {<br />&nbsp; &nbsp; &nbsp; &nbsp; public synchronized static String repeat(String string, int times) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StringBuilder out = new StringBuilder();<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (times-- &gt; 0) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; out.append(string);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return out.toString();<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /><br /><br />&nbsp; &nbsp; &nbsp; &nbsp; private static String getOnlyClassName(String classname) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (classname.indexOf("$") &lt; 1) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return isEmptyName(classname);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; String[] str = classname.split("\\\\$", 0);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return isEmptyName(str[0]);<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; private static String getLastClassMethod(String lastClassMethod, List&lt;String&gt; dummyDepthText, int logType) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(dummyDepthText.size() &gt; 0) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return isEmptyName(dummyDepthText.get(dummyDepthText.size()-logType));<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return lastClassMethod;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; private static List&lt;String&gt; getdepthTexts(int tid) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(!depthTexts.containsKey(tid)) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; depthTexts.put(tid, new ArrayList&lt;String&gt;());<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return depthTexts.get(tid);<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; private static int getdepthCounts(int tid) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(!depthCounts.containsKey(tid)) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; depthCounts.put(tid, 0);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return depthCounts.get(tid);<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; private static String isEmptyName(String methodName) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (methodName.length() &lt; 2) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return "NULL";<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return methodName;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; private static String getArgs(JoinPoint joinPoint, MethodSignature methodSignature) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Object[] objArray = joinPoint.getArgs();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; String[] sigParamNames = methodSignature.getParameterNames();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int i = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; String argName = "";<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StringBuilder argAll = new StringBuilder();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (Object obj : objArray) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (obj == null) continue;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; argName = sigParamNames[i];<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; argAll.append(argName + ":[" + obj.toString() + "] , ");<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (argAll.length() &gt; 1) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; argAll.insert(0, "args&nbsp; ");<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return argAll.toString();<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br /><br /><br /><br />&nbsp; &nbsp; public static void printTo(String category, String message) {<br />&nbsp; &nbsp; &nbsp; &nbsp; if (!category.equals(ASPECT_LOG_PLANTUML_TYPE)) return;<br />&nbsp; &nbsp; &nbsp; &nbsp; Log.d(category, message );<br />&nbsp; &nbsp; &nbsp; &nbsp; //--to db<br /><br /><br />&nbsp; &nbsp; &nbsp; &nbsp; if(logBufferCount &lt; logBufferStoreCountLimit) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; logBufferCount++;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; logBufferMessages += message + "\\n";<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; try {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (OptimalAgentApplication.getInstance() == null) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; }catch (Exception e) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; if (OptimalAgentApplication.TestLogController.logHelper != null) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OptimalAgentApplication.TestLogController.insert(category + " // " + message);<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; logBufferCount = 1;<br />&nbsp; &nbsp; &nbsp; &nbsp; logBufferMessages = "";<br />&nbsp; &nbsp; }<br /><br /><br /><br />}